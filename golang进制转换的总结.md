# 十六进制转二进制

```golang
// byte数组转二进制字符串，传入： [78 154 155 207 2 224 123 246 238 236 212 118 118 50 254 142 220 226 193 139 107 54 196 58 164 43 124 247 153 1 98 173]；返回类似：0100111010011010100110111100111100000010111000000111101111110110111011101110110011010100011101100111011000110010111111101000111011011100111000101100000110001011011010110011011011000100001110101010010000101011011111001111011110011001000000010110001010101101的字符串
func bytesToBin(bs []byte) (binString string) {
	for _, n := range bs {
		binString += fmt.Sprintf("%08b", n)
	}
	return
}
```

因为byte数组本身就是与uint8等价的，即每个字节是8位的整数，每个字节对应可以从ASCII表找到10进制与二进制的关系。


如果事先用byte数组转换位16进制字符串，再用16进制字符串转换到二进制也是可以的，上面的例子十六进制字符串是：4e9a9bcf02e07bf6eeecd4767632fe8edce2c18b6b36c43aa42b7cf7990162ad

```golang
func hexToBin(hex string) (binString string) {
    for i:=2;i<=len(hex);i=i+2 {
            c := hex[i-2:i]
            v, err := strconv.ParseUint(c, 16, 32);
            if  err != nil {
                fmt.Printf("%T, %v\n", c, err)
            }
            binString += fmt.Sprintf("%08b", v)
    }
	
	return
}

```

思路是取两个字符先转十进制数(因为ASCII表中十六进制由两个字符表示)，再由十进制转换到二进制字符串，因为printf的format格式中的%b必须是整型参数，所以需要转换一次，不能直接带入，而byte里的是uint8

因为都是字符类型的进制转换，所以都会ASCII表来转换，for循环hex字符串时，取出的都会转成对应的ascii表的整型，直接带入转换二进制会出现错误，除非先把十六进制字符串转成十六进制字面量